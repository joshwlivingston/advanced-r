[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "advanced-r",
    "section": "",
    "text": "This book contains all of my notes and exercise work-throughs from Hadley Wickham’s Advanced R, 2nd edition.\nSource code is organized at the chapter-section level. In each section, notes appear first, followed by the exercises. Exercise question text are written in italics.\nThis book was rendered using Quarto."
  },
  {
    "objectID": "ch02_namesvalues.html",
    "href": "ch02_namesvalues.html",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "",
    "text": "Book Link"
  },
  {
    "objectID": "ch02_namesvalues.html#binding-basics",
    "href": "ch02_namesvalues.html#binding-basics",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "1.1 2.2: Binding basics",
    "text": "1.1 2.2: Binding basics\n\n1.1.1 Notes\n\nA value does not have a name; a name has a value.\nThat is, a name gets bound to a value as a reference to that value.\nAssigning a second name to that object does not change the object or copy it. It simply assigns a new name as reference to that object.\nNames have to be pretty. See ?make.names for rules governing syntactically valid names. \n\n\n\n1.1.2 Exercises\n1. Explain the relationship between a, b, c, and d in the following code:\n\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\n\n a, b, and c all occupy the same space in memory. Thus, they are separate references, each of which have been assigned to the same object.\n\nlibrary(lobstr)\nobj_addr(a) == obj_addr(b) & obj_addr(b) == obj_addr(c)\n\n[1] TRUE\n\nprint(obj_addr(a))\n\n[1] \"0x7fa908b50f08\"\n\n\n\nHowever, d does not occupy the same memory space. Thus, d is an is a separate object from that of a, b, and c, with a unique reference. Both of these objects are the vector of integers 1 through 10.\n\nobj_addr(d) == obj_addr(a)\n\n[1] FALSE\n\nprint(obj_addr(d))\n\n[1] \"0x7fa908c53640\"\n\n\n\n2. The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object?\nAll accessors to the mean() function point to the same object in memory.\n\nobjs <- list(mean, base::mean, evalq(mean), match.fun(\"mean\"))\nobj_addrs(objs)\n\n[1] \"0x7fa9281de2e0\" \"0x7fa9281de2e0\" \"0x7fa9281de2e0\" \"0x7fa9281de2e0\"\n\n\n\n3. By default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behavior?\nColumn names often represent data, so renaming with make.names changes underlying data. You can suppress this with check.names = FALSE. \n4. What rules does make.names() use to convert non-syntactic names into syntactic ones?\nFrom the docs, “A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number.” Letters are defined by locale, but only ASCII digits are used. Invalid characters are translated to “.”. Missing is translated to “NA”. And reserved words have a “.” appended to them. Then, values are de-duplicated using make.unique(). \n5. I slightly simplified the rules that govern syntactic names. Why is .123e1 not a syntactic name?\nSyntactic names may start with a letter, or a dot not followed by a number. .123e1 starts with .1, so it is not a syntactically valid name."
  },
  {
    "objectID": "ch02_namesvalues.html#copy-on-modify",
    "href": "ch02_namesvalues.html#copy-on-modify",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "1.2 2.3: Copy-on-modify",
    "text": "1.2 2.3: Copy-on-modify\n\n1.2.1 Notes\nConsider the following two variables\n\nx <- c(1, 2, 3)\ny <- x\n\n\nNote from previously that x and y are different references to the same object.\n\nobj_addr(x) == obj_addr(y)\n\n[1] TRUE\n\n\n\nThis object is located at the following address:\n\nobj_addr(y)\n\n[1] \"0x7fa929f86618\"\n\n\n\nModifying the object assigned to y results in the creation of a new object.\n\ny[[3]] <- 4\nobj_addr(y)\n\n[1] \"0x7fa9296c0218\"\n\n\n We see that this is different than the original object’s address\n\nobj_addr(x) == obj_addr(y)\n\n[1] FALSE\n\n\n This behavior is called copy-on-modify; i.e., R objects are immutable – any changes results in the creation of a new object in memory. \n\n1.2.1.1 tracemem()\nbase::tracemem() will track an object’s location in memory.\n\nx <- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n\n<0x7fa9096e06a8> \n\n\n In the example below, a second name, y was assigned to an object, which already had an assigned name x. So when x or y is modified, copy-on-modify takes place. This will trigger tracemem() to print a memory change.\n\ny <- x\ny[[4]] <- 4L\n\ntracemem[0x7fa9096e06a8 -> 0x7fa929f2f068]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n base::untracemem() is the opposite of base::tracemem()\n\nuntracemem(x)\n\n\n\n\n1.2.1.2 Lists\nLists do not store values. Instead, they store references to them.\nWhen you modify elements of a list, you can view how this effects copy-on-modify behavior using lobstr::ref().\nHere, we assign a new reference to a list object. We then modify one of the elements in the list, triggering copy-on-modify. With lobstr::ref(), we see that a new object was created for the list itself and the modified object. The other elements of the list remain the same object.\nIn the output below, the first and fifth references are the lists themselves. The sixth references points to the new object, 4.\n\nl1 <- list(1, 2, 3)\nl2 <- l1\nl1[[3]] <- 4\nref(l1, l2)\n\n█ [1:0x7fa908861bc8] <list> \n├─[2:0x7fa908dc1598] <dbl> \n├─[3:0x7fa908dc1560] <dbl> \n└─[4:0x7fa908dc1410] <dbl> \n \n█ [5:0x7fa90a4ba2f8] <list> \n├─[2:0x7fa908dc1598] \n├─[3:0x7fa908dc1560] \n└─[6:0x7fa908dc14f0] <dbl> \n\n\n\n\n\n1.2.1.3 Data frames\nSince data frames are a list of columns, and those columns are vectors, modifying a column only results in that column being copied:\n\nd1 <- data.frame(a = c(1, 2, 3), b = c(4, 5, 6))\ntracemem(d1)\n\n[1] \"<0x7fa90a6bd008>\"\n\n\n Here, tracemem() shows us that the new column was copied to a new object in memory.\n\nd2 <- d1\nd2[, 2] <- d2[, 2] * 2\n\ntracemem[0x7fa90a6bd008 -> 0x7fa90a4c7308]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa90a4c7308 -> 0x7fa90a4c7248]: [<-.data.frame [<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n And with lobstr::ref(), we confirm that both the data.frame object and the second column were copied.\n\nref(d1, d2)\n\ntracemem[0x7fa90a6bd008 -> 0x7fa90a6d3708]: FUN lapply ref eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa90a4c7248 -> 0x7fa90a6e04c8]: FUN lapply ref eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n█ [1:0x7fa90a6bd008] <df[,2]> \n├─a = [2:0x7fa929f86ed8] <dbl> \n└─b = [3:0x7fa929f86de8] <dbl> \n \n█ [4:0x7fa90a4c7248] <df[,2]> \n├─a = [2:0x7fa929f86ed8] \n└─b = [5:0x7fa90b030218] <dbl> \n\n\n Since data.frames are built column-wise, modifying a row results in copying every column.\n\nd3 <- d1\nd1[1, ] <- d1[1, ] * 2\n\ntracemem[0x7fa90a6bd008 -> 0x7fa90a74d088]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa90a74d088 -> 0x7fa90a74cf08]: [<-.data.frame [<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n\n\nuntracemem(d1)\nref(d1, d3)\n\ntracemem[0x7fa90a6bd008 -> 0x7fa90a8cb648]: FUN lapply ref eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n█ [1:0x7fa90a74cf08] <df[,2]> \n├─a = [2:0x7fa918167828] <dbl> \n└─b = [3:0x7fa9181677d8] <dbl> \n \n█ [4:0x7fa90a6bd008] <df[,2]> \n├─a = [5:0x7fa929f86ed8] <dbl> \n└─b = [6:0x7fa929f86de8] <dbl> \n\n\n\n\n\n1.2.1.4 Character vectors\nR uses a global string pool in each session. This means that each element of a character vector points to a string in the globally unique pool. The references can be viewed in lobstr::ref() by setting character to TRUE.\n\nx <- letters[1:3]\nref(x, character = TRUE)\n\n█ [1:0x7fa9181880b8] <chr> \n├─[2:0x7fa9412f94e8] <string: \"a\"> \n├─[3:0x7fa9416077f8] <string: \"b\"> \n└─[4:0x7fa94100cac0] <string: \"c\"> \n\n\n\n\n\n\n1.2.2 Exercises\n1. Why is tracemem(1:10) not useful?\n1:10 is a sequence no name assigned to it, therefore will not be traceable after this initial call. \n2. Explain why tracemem() shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.\n\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\n[1] \"<0x7fa929c204c8>\"\n\nx[[3]] <- 4\n\ntracemem[0x7fa929c204c8 -> 0x7fa929292d48]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa929292d48 -> 0x7fa908ae92b8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\nuntracemem(x)\n\n In this example, the original object x is an integer vector. When the third element of the vector is modified to 4, a double, the vector is first modified by being converted to a double vector. Then it is modified again when the third element is modified. This results in two copies-on-modify, reflected in the tracemem() output."
  },
  {
    "objectID": "ch02_namesvalues.html#object-size",
    "href": "ch02_namesvalues.html#object-size",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "1.3 2.4: Object size",
    "text": "1.3 2.4: Object size\n\n1.3.1 Notes\nlobstr::obj_size() shows you the size of an object in memory.\n\nobj_size(iris)\n\n7,200 B\n\nobj_size(c(1, 2, 3))\n\n80 B\n\n\n\n\n1.3.1.1 Lists\nBecause lists store references to objects, a repeated list is smaller than one would imagine. This is because the reference occupies less space in memory than the object itself.\n\nl1 <- list(rep(100, 100000))\nobj_size(l1)\n\n800,104 B\n\nl2 <- list(l1, l1, l1)\nobj_size(l2)\n\n800,184 B\n\n\n A list repeated three times is 80 bytes larger than the original list, which was of size 800,104 bytes. 80 bytes is the size of a list of three empty objects:\n\nobj_size(list(NULL, NULL, NULL))\n\n80 B\n\n\n\n\n\n1.3.1.2 Character vectors\nSimilarly, since character vectors are references to the global string pool, a repeated character vector does not increase size dramatically:\n\ns <- \"ask me about my sentence\"\nobj_size(s)\n\n136 B\n\nobj_size(rep(s, 10))\n\n256 B\n\n\n\n\n\n1.3.1.3 Alternative representation\nStarting in R 3.5.0, alternative representation allowed R to represent certain vectors compactly. This is most commonly observed when using : to create a sequence.\nBecause of ALTREP, every sequence in R has the same size, regardless of the sequence length:\n\nobj_size(1:2)\n\n680 B\n\nobj_size(1:10)\n\n680 B\n\nobj_size(1:1e9)\n\n680 B\n\n\n\n\n\n\n1.3.2 Exercises\n1.In the following example, why are object.size(y) and obj_size(y) so radically different?\n\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n\n8005648 bytes\n\nobj_size(y)\n\n80,896 B\n\n\n\nPer the documentation, base::object.size() measures the size of each object, and does not account for shred objects within lists. \n2. Take the following list. Why is its size somewhat misleading?\n\nfuns <- list(mean, sd, var)\nobj_size(funs)\n\n17,608 B\n\n\n These objects come shipped with base R, so they are always available. It does not represent additional memory allocated to these objects."
  },
  {
    "objectID": "ch02_namesvalues.html#modify-in-place",
    "href": "ch02_namesvalues.html#modify-in-place",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "1.4 2.5: Modify-in-place",
    "text": "1.4 2.5: Modify-in-place\n\n1.4.1 Notes\nThere are two exceptions to copy-on-modify:\n\nObjects with a single binding\nEnvironments\n\nIn these exceptions, R executes a modify in place optimization. \n\n1.4.1.1 Objects with a single binding\nIf an object has only one name assigned to it, R will modify in place.\nBefore:\n\na <- c(1, 2, 3)\nref(a)\n\n[1:0x7fa9084c7f08] <dbl> \n\n\n After:\n\na[[3]] <- 4\nref(a)\n\n[1:0x7fa940128a08] <dbl> \n\n\n Note that this optimization does not apply when modifying a vector’s length. Here, z is assigned to a new object upon “adding” a fourth element to the vector z.\nBefore:\n\nz <- letters[1:3]\nobj_addr(z)\n\n[1] \"0x7fa929f4c1e8\"\n\n\n\nAfter:\n\nz[[4]] <- \"d\"\nobj_addr(z)\n\n[1] \"0x7fa9088ee018\"\n\n\n There are two complications in R’s behavior that limit execution of the modify-in-place optimization:\n\nR can only count if an object has 0, 1, or many references. That means that if an object has one of two bindings removed, the binding count will remain at many and modify-in-place will not apply.\nMost functions make a reference of the object to be modified, so copy-on-modify would apply. The exception are “primitive” C functions, found mostly in the base package.\n\nFor example, modifying a data frame results in additional references being made, whereas modifying a list uses internal C code that does not create new references.\nIt’s best to confirm copy behavior using tracemem().\nFirst, on modifying a data frame:\n\nx <- as.data.frame(matrix(runif(1e3), ncol = 4))\ntracemem(x)\n\n[1] \"<0x7fa90b0125c8>\"\n\nfor (i in seq_along(x)) {\n  x[[i]] <- x[[i]] * 5\n}\n\ntracemem[0x7fa90b0125c8 -> 0x7fa9180a7758]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a7758 -> 0x7fa9180a7668]: [[<-.data.frame [[<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a7668 -> 0x7fa9180a75c8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a75c8 -> 0x7fa9180a7488]: [[<-.data.frame [[<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a7488 -> 0x7fa9180a7398]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a7398 -> 0x7fa9180a72a8]: [[<-.data.frame [[<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a72a8 -> 0x7fa9180a7208]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x7fa9180a7208 -> 0x7fa9180a7118]: [[<-.data.frame [[<- eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\nuntracemem(x)\n\n Then a list:\n\nl <- as.list(x)\ntracemem(l)\n\n[1] \"<0x7fa90a9d1198>\"\n\nfor (i in seq_along(l)) {\n  l[[i]] <- l[[i]] * 5\n}\n\ntracemem[0x7fa90a9d1198 -> 0x7fa9180eb4e8]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\nuntracemem(l)\n\n\n\n\n1.4.1.2 Environments\nEnvironments are always modified-in-place, since existing bindings in that environment continue to have the same reference. \n\n\n\n1.4.2 Exercises\n1. Explain why the following code doesn’t create a circular list.\n\nx <- list()\nx[[1]] <- x\n\n In the first line of code, an empty list is created, and the name x assigned to it.\nThe next line of code modifies the length of x, so copy-on-modify takes place to create a new list of length one, with the first element being x, the original empty list.\nThis is confirmed by observing the matching memory addresses:\nOriginal list:\n\nx <- list()\nref(x)\n\n█ [1:0x7fa909ac6f20] <list> \n\n\n Modified list:\n\nx[[1]] <- x\nref(x)\n\n█ [1:0x7fa90a8c2b30] <list> \n└─█ [2:0x7fa909ac6f20] <list> \n\n\n\n2. Wrap the two methods for subtracting medians into two functions, then use the ‘bench’ package to carefully compare their speeds. How does performance change as the number of columns increase?\nNote: Instead of multiplying columns by 5 to demonstrate the exception to modify-in-place, the book subtracted medians. I’ll continue to multiply by 5 below.\nWith a 250 x 4 data set, the differences in both speed is about 6-8x.\n\nlibrary(bench)\nmult_five_seq <- function(x) {\n  for (i in seq_along(x)) {\n    x[[i]] <- x[[i]] * 5\n  }\n}\n\ndf <- as.data.frame(matrix(runif(1e4), ncol = 4))\nl <- as.list(df)\n\nbm <- mark(df = mult_five_seq(df), l = mult_five_seq(l))\nknitr::kable(bm[, 1:5])\n\n\n\n\nexpression\nmin\nmedian\nitr/sec\nmem_alloc\n\n\n\n\ndf\n45.21µs\n48.04µs\n19601.31\n99.9KB\n\n\nl\n3.79µs\n5.04µs\n182246.37\n78.3KB\n\n\n\n\n\n With a 250 x 400 data set, the differences in both speed and memory allocation are much more pronounced. Here, 70x faster and a quarter of the memory used.\n\ndf <- as.data.frame(matrix(runif(1e5), ncol = 400))\nl <- as.list(df)\n\nbm <- mark(df = mult_five_seq(df), l = mult_five_seq(l))\nknitr::kable(bm[, 1:5])\n\n\n\n\nexpression\nmin\nmedian\nitr/sec\nmem_alloc\n\n\n\n\ndf\n7.73ms\n7.84ms\n127.3152\n3.26MB\n\n\nl\n103.17µs\n108.96µs\n8917.0814\n803.17KB\n\n\n\n\n\n 3. What happens if you attempt to use tracemem() on an environment? Modify-in-place always applies to environments, since existing bindings keep their references."
  },
  {
    "objectID": "ch02_namesvalues.html#unbinding-the-garbage-collector",
    "href": "ch02_namesvalues.html#unbinding-the-garbage-collector",
    "title": "1  Advanced R Chapter 2 - Names and Values",
    "section": "1.5 2.6: Unbinding the garbage collector",
    "text": "1.5 2.6: Unbinding the garbage collector\n\n1.5.1 Notes\nR uses a garbage collector to automatically free up unused memory when it is needed for a new object. You can force a garbage collection with gc(), but there’s never any need to call it.\nAn example of unused memory are objects that no longer have a reference.\n\nx <- 1:3\nx <- 2:4\nrm(x)\n\n Two objects were created above as a result of the original object creation and the copy-on-modify behavior. Then, the name x was removed, but the objects remained. R’s garbage collector will remove these objects when necessary. You can have the collector print a message every time it runs with gcinfo(TRUE)."
  },
  {
    "objectID": "ch03_vectors.html",
    "href": "ch03_vectors.html",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "",
    "text": "Book Link"
  },
  {
    "objectID": "ch03_vectors.html#atomic-vectors",
    "href": "ch03_vectors.html#atomic-vectors",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.1 3.2: Atomic Vectors",
    "text": "2.1 3.2: Atomic Vectors\n\n2.1.1 Notes\n\nFour primary types of atomic vectors\n\nlogical\ncharacter\ndouble\ninteger\n\nTogether, double and integer are numeric vectors\n\n\nTwo rare types:\n\ncomplex\nraw \n\n\n\n2.1.1.1 Scalars\nScalars, aka individual values, are created in special ways for each of the four primary types:\n\n\n\n\n\n\n\nType\nValue\n\n\n\n\nLogical\nTRUE or FALSE (or T or F)\n\n\nCharacter\nsurrounded by \" or '. see ?Quotes for escape characters\n\n\nDouble\ndecimal (0.123), scientific (1.23e3), or hexadecimal form\n\n\nInteger\nsimilar to doubles, ending with L (123L)\n\n\n\n\nThere are three special values unique to doubles: Inf, -Inf, and NaN (not a number) \n\n\n\n2.1.1.2 c()\n\nc(), short for combine, is used to create longer vectors\nDetermine the vector type with typeof()\nIf the inputs to c() are other atomic vectors, R will flatten them into one atomic vector.\n\n\nx1 <- c(1, 2)\nx2 <- c(3, 4)\nc(x1, x2)\n\n[1] 1 2 3 4\n\n\n\n\n\n2.1.1.3 Missing values\n\nMissing values are represented with NA\n\nEach primary type has its own missing value (R usually converts to correct type)\n\n\n\n\n\nType\nMissing Value\n\n\n\n\nLogical\nNA\n\n\nCharacter\nNA_character\n\n\nDouble\nNA_real_\n\n\nInteger\nNA_integer_\n\n\n\n\nMost computations involving missing values will return a missing value, with a few exceptions:\n\nThe 0 power identity\n\nNA ^ 0\n\n[1] 1\n\n\n\nBoolean logic (or TRUE):\n\nNA | TRUE\n\n[1] TRUE\n\n\n\nBoolean logic (and FALSE):\n\nNA & FALSE\n\n[1] FALSE\n\n\n\n\nUse is.na() to check for missingness in vectors\n\n\nx <- c(NA, 2, 3, NA)\nis.na(x)\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\n\n\n\n2.1.1.4 Testing\nThe primary types can be checked with the appropriate is.*() function:\n\n\n\nType\nis.*() function\n\n\n\n\nLogical\nis.logical()\n\n\nCharacter\nis.character()\n\n\nDouble\nis.double()\n\n\nInteger\nis.integer()\n\n\n\n\n\n\n2.1.1.5 Coercion\nCoercion to a different type often happens automatically as a result of a computation. To deliberately coerce, use the appropriate as.*() function:\n\n\n\nType\nas.*() function\n\n\n\n\nLogical\nas.logical()\n\n\nCharacter\nas.character()\n\n\nDouble\nas.double()\n\n\nInteger\nas.integer()\n\n\n\nFailed coercion generates a warning and returns NA for that value.\n\nas.integer(c(\"1\", \"2.5\", \"bike\", \"7\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  2 NA  7\n\n\nPer ?c, the hierarchy of types when coercing is NULL < raw < logical < integer < double < complex < character < list < expression \n\n\n\n2.1.2 Exercises\n1. How do you create raw and complex scalars? (See ?raw and ?complex.)\nRaw vectors are created with raw(), specifying the single length argument. Raw vectors also have a specific is.raw() for checking and as.raw() for coercion.\n\nr <- raw(2)\nr\n\n[1] 00 00\n\n\n\nComplex vectors are created with complex(), specifying either the length (via the length.out argument) or both the real and imaginary parts as numeric vectors. \n2. Test your knowledge of the vector coercion rules by predicting the output of the following uses of c()\nPer the type coercion hierarchy, c(1, FALSE) will be converted to a double, c(1, 0). 1’s are coerced to TRUE (and 0 to FALSE), and vice versa\n\nx <- c(1, FALSE)\ncat(x, \"\\n\", typeof(x))\n\n1 0 \n double\n\n\n\nc(\"a\", 1), will be coerced to c(\"a\", \"1\") as the character type is about double in the type coversion hierarchy\n\nx <- c(\"a\", 1)\ncat(x, \"\\n\", typeof(x))\n\na 1 \n character\n\n\n\nc(TRUE, 1L), will b coerced to c(1L, 1L) per the type coercion hierarchy\n\nx <- c(TRUE, 1L)\ncat(x, \"\\n\", typeof(x))\n\n1 1 \n integer\n\n\n\n3.1. Why is 1 == \"1\" true?\nPer the documentation for ==, atomic vectors that are of different types are coerced prior to evaluation. So, the left hand of the equality, 1, will be coerced to a character vector prior to evaluation. Once coerced, the call is \"1\" == \"1\", which is clearly true.\n3.2. Why is -1 < FALSE true?\n<, like ==, also coerces types prior to evaluation. So after coercion, the call here becomes -1 < 0, which is true.\n3.3. Why is \"one\" < 2 false?\nPer the documentation for <, string comparison is done at the locale level. The locale in use can be viewed with Sys.getlocale() and similarly set with Sys.setlocale(). Because numbers come before letters in this sequence, the coerced inequality, \"one\" < \"2\" is evaluated as FALSE. \n4. Why is the default missing value, NA, a logical vector? What’s special about logical vectors? (Hint: think about c(FALSE, NA_character_).)\nLogical vectors are lowest on the type hierarchy. When they are combined with another primary type, logicals will always be coerced into the other type. \n5. Precisely what do is.atomic(), is.numeric(), and is.vector() test for?\n\nis.atomic() checks if an object is of type “logical”, “integer”, “numeric”, “complex”, “character” or “raw”\nis.numeric() checks if an object is a double or integer vector and not a factor.\nis.vector() is a generalized is.*() function for all vectors. The mode argument can be specified to check for a specific type, including lists. It can also be left as “any”, the default, to check is the object is a vector. mode can also be specified as “numeric”, running the same check as is.numeric()."
  },
  {
    "objectID": "ch03_vectors.html#attributes",
    "href": "ch03_vectors.html#attributes",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.2 3.3: Attributes",
    "text": "2.2 3.3: Attributes\n\n2.2.1 Notes\n\n2.2.1.1 Getting and setting\n\nAttributes are name-value pairs that attach metadata to an R object\nIndividual attributes can be get and set with attr()\nAttributes are retrieved en masse with attributes() and set with structure()\nMost attributes, other than dim and names are lost by most operations\n\nTo define and preserve attributes, create an S3 class, discussed in Chapter 13 \n\n\n\n\n2.2.1.2 Names\n\nNames can be set in three ways:\n\n\n# When creating it: \nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n\n\n\nNames should be unique and non-missing, though this is not enforced in R \n\n\n\n2.2.1.3 Dimensions\n\nAdding the dim attribute allows a vector to behave like a 2-d matrix or multi-dimensional array\n\nYou can also create matrices and arrays with matrix() and array()\n\nIf a vector has no dim attribute set, that is equivalent to a vector with NULL dimensions\nMany functions for working with vectors have generalizations for working with matrices and arrays \n\n\n\n\n2.2.2 Exercises\n1. How is setNames() implemented? How is unname() implemented? Read the source code.\nsetNames() assigns names to the object by calling names()<-\n\nsetNames\n\nfunction (object = nm, nm) \n{\n    names(object) <- nm\n    object\n}\n<bytecode: 0x7fc66bcfda98>\n<environment: namespace:stats>\n\n\n\nunname() sets names to NULL using names()<-. If the object is a data frame, or force is set to TRUE, the dimension names are set to NULL using dimnames()<-\n\nunname\n\nfunction (obj, force = FALSE) \n{\n    if (!is.null(names(obj))) \n        names(obj) <- NULL\n    if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) \n        dimnames(obj) <- NULL\n    obj\n}\n<bytecode: 0x7fc68a960798>\n<environment: namespace:base>\n\n\n\n2.1 What does dim() return when applied to a 1-dimensional vector?\nThe dimensions of a 1-d vector are NULL, so dim() returns NULL.\n\nx <- c(1, 2, 3)\ndim(x)\n\nNULL\n\n\n\n2.2 When might you use NROW() or NCOL()?\nThe difference between NROW() and nrow() (and NCOL() and ncol()) is that the capitalized forms return values for one dimensional vectors. Both functions return the same value for matrices, arrays, and data frames.\nFor one dimensional objects: - NROW() returns the length of the vector - NCOL() returns 1L >\n3. How would you describe the following three objects? What makes them different from 1:5?\n\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\n\n\nx1, x2, and x3 are all one dimensional arrays in a 3 dimensional space. Each has a numeric vector of length 3 as the dim attribute. 1:5, being a 1 dimensional vector, does not have a dim attribute.\n\ndim(1:5)\n\nNULL\n\n\n\n4. An early draft used this code to illustrate structure():\n\nstructure(1:5, comment = \"my attribute\")\n\n[1] 1 2 3 4 5\n\n\n\nBut when you print that object you don’t see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)\nChecking the documentation for the default method for print(), (?print.default), we see that attributes are printed depending on an object’s class(es).\n1:5 is stored as an “integer”\n\nclass(1:5)\n\n[1] \"integer\"\n\n\n\nSince there is no print method defined for “integer”, print.default() will be used and no attributes printed.\nIf we wanted the attribute comment to be printed with the output, we would have to create an S3 class with and attribute comment and define a print method for that class that includes the comment attribute."
  },
  {
    "objectID": "ch03_vectors.html#s3-atomic-vectors",
    "href": "ch03_vectors.html#s3-atomic-vectors",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.3 3.4: S3 atomic vectors",
    "text": "2.3 3.4: S3 atomic vectors\n\n2.3.1 Notes\nDiscussed more in Chapter 13, S3 objects have a class attribute, which means it will have special behavior for generic functions.\nThere are four important S3 vectors in base R:\n\nCategorical data in factor vectors, an integer\nDates in Date vectors, a double\nDate-times in POSIXct vectors, a double\nDurations in difftime vectors, a double \n\n\n2.3.1.1 Factors\nFactors are useful when looking at categorical data. They sit on top of integers with two attributes:\n\nclass: “factor”\nlevels: defines factor’s categories\n\nOrdered factors are just like factors, except that the order of the factors is meaningful \n\n\n2.3.1.2 Dates\nDates are built on double vectors with a class attribute “Date”.\nThe value of the double represents the number of days since 1970-01-01.\n\nd <- as.Date(\"1971-01-01\")\nunclass(d)\n\n[1] 365\n\n\n\n\n\n2.3.1.3 Date-times\nR stores date-time data in two ways, POSIXct, and POSIXlt. POSIX stands for Portable Operating System Interface, ct for calendar time, and lt for local time. POSIXct is the simplest usage.\nPOSIXct variables are built on top of double variables, with two attributes:\n\nclass: “POSIXct”\ntzone: “UTC”, “GMT”, “” for local, or a timezone name\n\nThe tzone attributes controls the timezone, and can be modified using attr() or structure(). See this Wikipedia page for a list of the timezone names and ?timezones for where to locate the tz database on your system. \n\n\n2.3.1.4 Durations\nDurations, representing the time between two dates or date-times, are stored in difftimes.\nDifftimes are built on doubles with a units attribute that determines how the duration should be calculated. \n\n\n\n2.3.2 Exercises\n1. What sort of object does table() return? What is its type? What attributes does it have? How does the dimensional change as you tabulate more variables?\nFrom viewing its structure with str(), we see that t is a built on an integer, appearing to be a 1-dimensional array. It has an additional attribute dimnames containing the factor levels.\n\nx <- c(\"cat\", \"dog\", \"dog\")\nf <- factor(x, levels = c(\"cat\", \"dog\", \"horse\"))\nt <- table(f)\nstr(t)\n\n 'table' int [1:3(1d)] 1 2 0\n - attr(*, \"dimnames\")=List of 1\n  ..$ f: chr [1:3] \"cat\" \"dog\" \"horse\"\n\n\n\nLooking at dim(t) we confirm that this is a 1 dimensional array.\n\ndim(t)\n\n[1] 3\n\n\n\nattributes() also provides a clean look at t\n\nattributes(t)\n\n$dim\n[1] 3\n\n$dimnames\n$dimnames$f\n[1] \"cat\"   \"dog\"   \"horse\"\n\n\n$class\n[1] \"table\"\n\n\n\nFor each variable added to the tabulation, the dimensionality increases by 1. Here with two variables, we note that t2 is a two dimensional array.\n\ny <- c(\"female\", \"male\", \"female\")\ng <- factor(y)\nt2 <- table(f, g)\nattributes(t2)\n\n$dim\n[1] 3 2\n\n$dimnames\n$dimnames$f\n[1] \"cat\"   \"dog\"   \"horse\"\n\n$dimnames$g\n[1] \"female\" \"male\"  \n\n\n$class\n[1] \"table\"\n\n\n\nAnd t3, with three tabulated variables, is a three dimensional array.\n\nz <- c(\"black\", \"black\", \"brown\")\nh <- factor(z)\nt3 <- table(f, g, h)\nattributes(t3)\n\n$dim\n[1] 3 2 2\n\n$dimnames\n$dimnames$f\n[1] \"cat\"   \"dog\"   \"horse\"\n\n$dimnames$g\n[1] \"female\" \"male\"  \n\n$dimnames$h\n[1] \"black\" \"brown\"\n\n\n$class\n[1] \"table\"\n\n\n\n2. What happens to a factor when you modify its levels?\nUsing tracemem(), we see that this is considered a modification, so copy-on-modify takes place.\n\nf1 <- factor(letters)\ntracemem(f1)\n\n[1] \"<0x7fc669a80128>\"\n\nlevels(f1) <- rev(levels(f1))\n\ntracemem[0x7fc669a80128 -> 0x7fc669a7b208]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file <Anonymous> <Anonymous> execute .main \n\n\n\n3. What does this code do? How do f2 and f3 differ from f1?\n\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))\n\n\nThe key difference here is the order of the levels in each output. Since rev() reverses the vector’s values, not the values the levels attributes the levels for f2, are in alphabetical order:\n\nlevels(f2)[1:5]\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\nFor f3, the levels are in reverse alphabetical order, as rev() was called on the levels themselves when it was created.\n\nlevels(f3)[1:5]\n\n[1] \"z\" \"y\" \"x\" \"w\" \"v\""
  },
  {
    "objectID": "ch03_vectors.html#lists",
    "href": "ch03_vectors.html#lists",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.4 3.5: Lists",
    "text": "2.4 3.5: Lists\n\n2.4.1 Notes\n\n2.4.1.1 Creating\nLists can be created using list().\n\nLists contain references to other objects\nA list’s those objects can be of any type, including other lists\nBecause a list can contain another list, lists are sometimes called recursive vectors\nc() combines multiple lists into one. If some of the inputs to c() are atomic vectors and others lists, R will coerce the vectors to lists prior to combining \n\n\n\n2.4.1.2 Testing and coercion\n\ntypeof() returns “list” for lists\nCheck if a list with is.list() and coerce to a list with as.list()\nYou can also coerce a list to an atomic vector with unlist()\n\nFrom the book, The rules for the type resulting from unlist() are “complex, not well documented, and not always equivalent to what you’d get with c()” \n\n\n\n\n2.4.1.3 Matrices and arrays\nSimilarly to atomic vectors, you can add a dim attribute to lists to create list-matrices or list-arrays, if you want to. \n\n\n\n2.4.2 Exercises\n1. List all the ways that a list differs from an atomic vector.\n\nBecause a list contains references, the list’s elements can be of any type\nA list stores references to other objects in memory, while a vector only stores one object in memory\n\nHere, the vector is seen occupying one location in memory\n\nlibrary(lobstr)\nx <- letters\nref(x)\n\n[1:0x6000026ad900] <chr> \n\n\n\nWhile the list occupies several locations. Note also that x and letters are references to the same object in memory\n\nl <- list(x, LETTERS, letters)\nref(l)\n\n█ [1:0x7fc66b8b2f08] <list> \n├─[2:0x6000026ad900] <chr> \n├─[3:0x6000026ad500] <chr> \n└─[2:0x6000026ad900] \n\n\n\n2. Why do you need to use unlist() to convert a list to an atomic vector? Why doesn’t as.vector() work?\nSince lists are types of vectors, the list itself will be returned when passed to as.vector(). This is confirmed per the documentation at ?as.vector. \n3. Compare and contrast c() and unlist() when combining a date and date-time into a single vector.\n\nd <- Sys.Date()\ndt <- Sys.time()\n\n\nc() coerces into a Date or POSIXct variable, whichever is called first.\n\nDate first:\n\nx1 <- c(d, dt)\nstr(x1)\n\n Date[1:2], format: \"2022-07-09\" \"2022-07-09\"\n\n\n\nPOSIXct first:\n\nx2 <- c(dt, d)\nstr(x2)\n\n POSIXct[1:2], format: \"2022-07-09 10:16:44\" \"2022-07-08 20:00:00\"\n\n\n\n\nunlist() takes a list and returns the atomic components only, so it coerces both elements into a double and returns the resulting atomic vector.\n\n\ny <- unlist(list(d, dt))\nstr(y)\n\n num [1:2] 1.92e+04 1.66e+09"
  },
  {
    "objectID": "ch03_vectors.html#data-frames-and-tibbles",
    "href": "ch03_vectors.html#data-frames-and-tibbles",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.5 3.6: Data frames and tibbles",
    "text": "2.5 3.6: Data frames and tibbles\n\n2.5.1 Notes\nData frames and tibbles are two important S3 vectors built on lists\n\nData frames are a named list of vectors with three attributes:\n\nnames for column names\nrow.names for row names\nclass, “data.frame”\n\nUnlike regular lists, data frames have a requirement that all vector elements have the same NROW()\n\nMost of the time, this is equivalent to saying all columns must have the same length. However, as we’ll see later, data frames can be columns, so stating the requirement in terms of NROW() is necessary to accommodate these cases.\nGives data frames the same properties as matrices\n\nTibbles are a modern “equivalent” to a data.frame, provided by the tibble package.\n\n\nlibrary(tibble)\nt <- tibble()\nattributes(t)\n\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\ninteger(0)\n\n$names\ncharacter(0)\n\n\n\n\n2.5.1.1 Creating\n\ndata.frame() to create data frames\ntibble::tibble() to create tibbles\n\nDifferences in creation between tibbles and data frames:\n\nTibbles never coerce vectors\n\nA common need is to suppress string to factor coercion in data.frame() by setting stringsAsFactors to FALSE\n\nTibbles surround non-syntactic names with ` rather than transforming them\nData frames recycle inputs that are an integer multiple of the longest vector, while tibbles only recycle vectors that are of length 1\nTibbles allow you to refer to created variables during construction \n\n\n\n2.5.1.2 Row names\nA character vector can be supplied to label the “rows” of a data frame, in two ways:\n\nThe row.names argument in data.frame()\nBy calling rownames()\n\nTibbles do not support row names for three main reasons - Row names are stored differently from data - They only work when rows can be identified via a single string - They must be unique, so repetition/resampling results in new row names\nRow names can be converted to a column in a tibble using rownames_to_column() or the rownames argument in as_tibble() \n\n\n2.5.1.3 Printing\nFour main differences between the print() output for a data frames and for tibbles:\n\nTibbles show the first 10 rows and all columns that fit on screen\nColumns are labelled with its abbreviated type\nWide columns are truncated\nColor is used when supported to (de)emphasize information \n\n\n\n2.5.1.4 Subsetting\nDiscussed more in Chapter 4, you can subset data frames and tibbles like a 1-D list or a 2-D matrix.\nTibbles modify two undesirable properties of data frames:\n\nData frames will return a vector for df[, x] if x is a length one vector, and a data frame if x is of length > 1, unless you specify df[, x, drop = FALSE]\n\nTibbles always return another tibble when using [\nSubsetting a single column from a tibble using [, however, can cause an issue with some legacy code that expects an atomic vector when calling df[, \"col\"]. Use df[[\"col\"]] to unambiguously return the desired column as an atomic vector whether subsetting a data frame or tibble\n\n\n\ndf1 <- data.frame(xyz = \"a\")\ndf2 <- tibble(xyz = \"a\")\nx <- \"xyz\"\ndf1[, x]\n\n[1] \"a\"\n\ndf1[, x, drop = FALSE]\n\n  xyz\n1   a\n\ndf2[, x]\n\n# A tibble: 1 × 1\n  xyz  \n  <chr>\n1 a    \n\n\n\n\nWhen using $ data frames will return any variable that starts with the input\n\n\nstr(df1$x)\n\n chr \"a\"\n\n\n\nTibbles only return exact matches with $\n\nstr(df2$x)\n\nWarning: Unknown or uninitialised column: `x`.\n\n\n NULL\n\n\n\n\n\n2.5.1.5 Testing and coercing\n\nCheck with is.data.frame() or is_tibble()\nCoerce with as.data.frame() or as_tibble() \n\n\n\n2.5.1.6 List columns\nSince data frames are lists of vectors, a data frame can have a column as a list.\nAdding a list column involves an extra step in data frames:\n\n# Either after the data frame is created\nd <- data.frame(a = 1:3)\nd$b <- list(4:6)\n\n\nLists are fully supported in tibbles\n\nd <- tibble(\n  a = 1:3,\n  b = list(4:6)\n)\n\n\n\n\n2.5.1.7 Matrix and data frame columns\nExtending the length requirement for data frames (that all columns must be of the same length), it’s actually the NROW() of each column that needs to match. Because of this, data frames and matrices can be included as columns in a data frame.\nJust as with list columns, it must be added after creation or wrapped in I(). Note that wrapping it in I() adds a class “AsIs”\n\nd0 <- data.frame(a = 1:3, b = 4:6)\nd <- data.frame(x = -2:0, y = I(d0))\nstr(d)\n\n'data.frame':   3 obs. of  2 variables:\n $ x: int  -2 -1 0\n $ y:Classes 'AsIs' and 'data.frame':   3 obs. of  2 variables:\n  ..$ a: int  1 2 3\n  ..$ b: int  4 5 6\n\n\n\nMany functions that work with columns assume that all columns are vectors, so use with caution. \n\n\n\n2.5.2 Exercises\n1. Can you have a data frame with zero rows? What about zero columns?\nYou can create an empty data frame with zero rows and zero columns.\n\nd <- data.frame()\nstr(d)\n\n'data.frame':   0 obs. of  0 variables\n\n\n\nYou can add an empty row, but its value is inaccessible\n\nd[1, ] <- 1L\nd[1, ]\n\ndata frame with 0 columns and 1 row\n\n\n\nSame outcome for row without a column in a tibble\n\nd <- tibble()\nd[1, ] <- 1L\nd[1, ]\n\n# A tibble: 1 × 0\n\n\n\nYou can add an empty columns during or after creation\n\nd <- data.frame(x = character())\nd$y <- vector(\"list\")\nstr(d)\n\n'data.frame':   0 obs. of  2 variables:\n $ x: chr \n $ y: list()\n\n\n\n2. What happens if you attempt to set rownames that are not unique?\nR will throw an error\n\ndata.frame(a = 1:3, row.names = rep(\"x\", 3))\n\n\n\nError in data.frame(a = 1:3, row.names = rep(\"x\", 3)) :\n  duplicate row.names: x\nNULL\n\n\n\n3. If df is a data frame, what can you say about t(df), and t(t(df))? Perform some experiments, making sure to try different column types.\nIf df can behave like a matrix, t() will operate as expected\n\nd <- data.frame(a = 1:2, b = 3:4)\nt(d)\n\n  [,1] [,2]\na    1    2\nb    3    4\n\nt(t(d))\n\n     a b\n[1,] 1 3\n[2,] 2 4\n\n\n\nPrior to transposing, t() coerces df to a matrix. Non-atomic vectors are coerced by as.vector(). For lists, as.vector() returns the list, so transposition occurs at the list-element level.\nLooking at the matrix object created as a first step, we see that the matrix preserved all variable types when coercing a list column into a matrix column. Remember that matrices are two dimensional vectors\n\nd <- data.frame(a = 1:3, b = I(list(\"4\", 5, 6L)))\nstr(as.matrix(d))\n\nList of 6\n $ : int 1\n $ : int 2\n $ : int 3\n $ : chr \"4\"\n $ : num 5\n $ : int 6\n - attr(*, \"dim\")= int [1:2] 3 2\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:2] \"a\" \"b\"\n\n\n\nSo t() works as “expected” with list columns\n\nt(d)\n\n  [,1] [,2] [,3]\na 1    2    3   \nb \"4\"  5    6   \n\nt(t(d))\n\n     a b  \n[1,] 1 \"4\"\n[2,] 2 5  \n[3,] 3 6  \n\n\n\nFor data frame columns, as.matrix() will combine the data frame columns (and any nested data frame columns) with the containing data frame.\n\nd <- data.frame(a = 1:3, b = 4:6)\nd$c <- data.frame(x = 101:103, y = 104:106)\nd0 <- data.frame(z = 1001:1003)\nd0$zz <- data.frame(z0 = 1:3, z1 = 4:6)\nd$d <- d0\nas.matrix(d)\n\n     a b c.x c.y  d.z d.zz.z0 d.zz.z1\n[1,] 1 4 101 104 1001       1       4\n[2,] 2 5 102 105 1002       2       5\n[3,] 3 6 103 106 1003       3       6\n\n\n\nt() works with data frame columns normally after combining\n\nt(d)\n\n        [,1] [,2] [,3]\na          1    2    3\nb          4    5    6\nc.x      101  102  103\nc.y      104  105  106\nd.z     1001 1002 1003\nd.zz.z0    1    2    3\nd.zz.z1    4    5    6\n\nt(t(d))\n\n     a b c.x c.y  d.z d.zz.z0 d.zz.z1\n[1,] 1 4 101 104 1001       1       4\n[2,] 2 5 102 105 1002       2       5\n[3,] 3 6 103 106 1003       3       6\n\n\n\n4. What does as.matrix() do when applied to a data frame with columns of different types? How does it differ from data.matrix()?\nThe behavior for as.matrix() is described in answer 3.\ndata.matrix() converts all variables in a data frame to numeric via as.numeric() prior to combining them, so I would expect odd behavior when converting non numeric variable types\nLogical and factor columns are coerced to integers. Character columns are converted first to factors, then to integers\n\na <- letters[1:3]\nas.integer(as.factor(a))\n\n[1] 1 2 3\n\n\n\nSo data.matrix() will use the resulting integer column for the resulting matrix\n\nb <- c(TRUE, TRUE, FALSE)\nc <- factor(LETTERS[1:3])\nd <- data.frame(a, b, c)\ndata.matrix(d)\n\n     a b c\n[1,] 1 1 1\n[2,] 2 1 2\n[3,] 3 0 3\n\n\n\nAny non numeric column that is not a logical, factor, or character column is converted to a numeric column via as.numeric(). as.numeric() only works on atomic vectors, so it will convert each list element at the atomic level\n\nb <- list(a = 1, b = \"2\", c = 3L)\nd <- data.frame(b = b)\ndata.matrix(d)\n\n     b.a b.b b.c\n[1,]   1   1   3\n\n\n\nSimilar application for data frames, being lists themselves\n\nc <- data.frame(c1 = 4:6, c2 = 7:9)\nd <- data.frame(a = 1:3, c = c)\ndata.matrix(d)\n\n     a c.c1 c.c2\n[1,] 1    4    7\n[2,] 2    5    8\n[3,] 3    6    9"
  },
  {
    "objectID": "ch03_vectors.html#null",
    "href": "ch03_vectors.html#null",
    "title": "2  Advanced R Chapter 3 - Vectors",
    "section": "2.6 3.7: NULL",
    "text": "2.6 3.7: NULL\n\n2.6.1 Notes\n\nNULL is a data structure with a unique type, “NULL”\n\n\ntypeof(NULL)\n\n[1] \"NULL\"\n\n\n\n\nNULL is always length zero\n\n\nlength(NULL)\n\n[1] 0\n\n\n\n\nNULL cannot have any attributes\n\n\nx <- NULL\nattr(x, a) <- 1L\n\n\n\nError in attr(x, a) <- 1L : attempt to set an attribute on NULL\nNULL\n\n\n\nTwo common uses of NULL:\n\nTo represent an empty vector\nTo represent an absent vector\n\nNULL is often used as a default function value, to signify that that value is not needed in the function.\nNA, in contrast, signifies that the element of a vector is absent, not the vector itself"
  }
]